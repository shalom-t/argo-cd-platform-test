#############################################
# Superset helm chart additional values file #
#############################################

# Service configuration
service:
  # Service type is ClusterIP
  # Reason: Exposes Superset service internally within the Kubernetes cluster.
  # This is typical for applications accessed behind an ingress or reverse proxy,
  # instead of direct external access.
  type: ClusterIP
  # Port where Superset listens internally
  # Reason: Superset's default web server runs on 8088.
  port: 8088 # 8088 is the default port for Superset

# Extra environment variables (key-value format)
# Note: ROW_LIMIT is set in configOverrides.secret below (Superset Python config)
extraEnv: {}

# Extra environment variables in RAW format
extraEnvRaw:
  - name: EMAIL_NOTIFICATIONS
    value: "True"
  - name: SMTP_HOST
    value: "192.168.100.111" # üëà your host IP
  - name: SMTP_PORT
    value: "1025"
  - name: SMTP_STARTTLS
    value: "False" # no TLS for local debug server
  - name: SMTP_SSL
    value: "False"
  - name: SMTP_USER
    value: ""
  - name: SMTP_PASSWORD
    value: ""
  - name: SMTP_MAIL_FROM
    value: "superset@test.local"
  - name: ENABLE_ALERTS_REPORTS
    value: "True"

# Bootstrap and initialize Superset database and admin user
init:
  # When enabled, Helm will create a Kubernetes Job to initialize Superset.
  # The Job runs database migrations and creates the initial admin user.
  # This is controlled by this 'enabled' flag.
  # enabled: true
  adminUser:
    # These values are passed as environment variables to the init Job.
    # Superset's init script uses them to create the admin user.
    # Superset Application user layer creation
    username: admin
    firstname: Superset
    lastname: Admin
    email: admin@superset.local
    password: admin1234

# Superset connection configuration
# These values tell Superset how to connect to PostgreSQL and Redis
supersetNode:
  connections:
    # Redis connection for caching and Celery
    redis_host: "{{ .Release.Name }}-redis-headless"
    redis_port: "6379"
    redis_password: superset
    # PostgreSQL connection for metadata
    db_host: "{{ .Release.Name }}-postgresql"
    db_port: "5432"
    db_user: superset
    db_pass: superset
    db_name: superset

# Celery Beat - not needed for user registration emails, but keep for future use
supersetCeleryBeat:
  enabled: true

configOverrides:
  # Secret key for encryption
  secret: |
    SECRET_KEY = 'QjgIqDzX7utN2qCp4YrtML+Co5U/oQxSo3F30KFh6V3RCb0Myi2bfVlZ'
    
    # Query row limit
    ROW_LIMIT = 5000

    # Enable proxy fix
    ENABLE_PROXY_FIX = True
  
  # Custom security manager for user registration emails  
  custom_security: |
    import os
    import smtplib
    import logging
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    from superset.security import SupersetSecurityManager
    from flask_appbuilder.security.views import UserModelView
    
    # Setup logging
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    
    # SMTP/Email Configuration
    SMTP_HOST = os.getenv('SMTP_HOST', '192.168.100.111')
    SMTP_PORT = int(os.getenv('SMTP_PORT', '1025'))
    SMTP_STARTTLS = os.getenv('SMTP_STARTTLS', 'False') == 'True'
    SMTP_SSL = os.getenv('SMTP_SSL', 'False') == 'True'
    SMTP_USER = os.getenv('SMTP_USER', '')
    SMTP_PASSWORD = os.getenv('SMTP_PASSWORD', '')
    SMTP_MAIL_FROM = os.getenv('SMTP_MAIL_FROM', 'superset@test.local')
    
    logger.info(f"üìß Email config SMTP_HOST={SMTP_HOST}, SMTP_PORT={SMTP_PORT}")
    print(f"üìß Email config SMTP_HOST={SMTP_HOST}, SMTP_PORT={SMTP_PORT}")
    
    # Temporary storage for plain passwords before hashing
    temp_passwords = {}
    
    def send_welcome_email(username, first_name, last_name, email, roles, plain_password):
        """Send welcome email to new user with plain-text password"""
        try:
            if not email:
                logger.warning(f"‚ö†Ô∏è No email for user {username}")
                return False
            
            logger.info(f"üì® Sending email to {email} with pwd {plain_password[:4]}***")
            print(f"üì® Sending email to {email}")
            
            # Create email message
            msg = MIMEMultipart()
            msg['Subject'] = "Welcome to Superset!"
            msg['From'] = SMTP_MAIL_FROM
            msg['To'] = email
            
            # Email body with plain-text password
            role_names = ', '.join([r.name for r in roles]) if roles else 'User'
            body = f"""Hello {first_name or username},
    
    Your Superset account has been created successfully!
    
    Username {username}
    Email {email}
    Role(s) {role_names}
    Initial assigned password {plain_password}
    
    You can log in at http://superset.local:8088
    
    For security reasons, please change your password after your first login.
    
    Enjoy exploring your data!
    
    Best regards,
    The Superset Team
    """
            msg.attach(MIMEText(body, 'plain'))
            
            # Send email using SMTP
            logger.info(f"üîå Connecting to SMTP {SMTP_HOST}:{SMTP_PORT}")
            
            if SMTP_SSL:
                server = smtplib.SMTP_SSL(SMTP_HOST, SMTP_PORT, timeout=10)
            else:
                server = smtplib.SMTP(SMTP_HOST, SMTP_PORT, timeout=10)
            
            if SMTP_STARTTLS and not SMTP_SSL:
                server.starttls()
            
            if SMTP_USER and SMTP_PASSWORD:
                server.login(SMTP_USER, SMTP_PASSWORD)
            
            server.send_message(msg)
            server.quit()
            
            logger.info(f"‚úÖ Welcome email sent to {email}")
            print(f"‚úÖ Welcome email sent to {email}")
            return True
        except Exception as e:
            logger.error(f"‚ùå Failed to send email {str(e)}", exc_info=True)
            print(f"‚ùå Failed to send email {str(e)}")
            return False
    
    # Custom UserModelView to intercept form submission
    class CustomUserModelView(UserModelView):
        def pre_add(self, item):
            """Called before user is added via UI - capture plain password"""
            logger.info(f"üë§ pre_add called for {item.username}")
            print(f"üë§ pre_add called for {item.username}")
            
            # Store the plain password before it gets hashed
            if hasattr(item, 'password') and item.password:
                temp_passwords[item.username] = item.password
                logger.info(f"üíæ Stored password for {item.username}")
                print(f"üíæ Stored password for {item.username} {item.password[:4]}***")
    
    # Custom Security Manager
    class CustomSecurityManager(SupersetSecurityManager):
        usermodeview = CustomUserModelView
        
        def __init__(self, appbuilder):
            super().__init__(appbuilder)
            logger.info("üîß CustomSecurityManager initialized!")
            print("üîß CustomSecurityManager initialized!")
            
            # Register SQLAlchemy event listener
            from sqlalchemy import event
            event.listen(self.user_model, 'after_insert', self.user_after_insert)
            logger.info("üîß Registered after_insert event listener")
            print("üîß Registered after_insert event listener")
        
        def user_after_insert(self, mapper, connection, target):
            """Called after user is inserted into database"""
            logger.info(f"üÜï User inserted {target.username}, email {target.email}")
            print(f"üÜï User inserted {target.username}")
            
            # Retrieve the plain password we stored earlier
            plain_password = temp_passwords.pop(target.username, None)
            
            if plain_password and target.email:
                logger.info(f"üìß Sending email with password {plain_password[:4]}***")
                print(f"üìß Sending email to {target.email}")
                
                roles = list(target.roles) if hasattr(target, 'roles') else []
                send_welcome_email(
                    target.username,
                    target.first_name,
                    target.last_name,
                    target.email,
                    roles,
                    plain_password
                )
            else:
                logger.warning(f"‚ö†Ô∏è No password found for {target.username}")
                print(f"‚ö†Ô∏è No password to send for {target.username}")
    
    # Register custom security manager
    CUSTOM_SECURITY_MANAGER = CustomSecurityManager
    
    logger.info("‚úÖ CustomSecurityManager registered")
    print("‚úÖ CustomSecurityManager registered")


# PostgreSQL for metadata storage
postgresql:
  # To overwrite the image
  image:
    registry: docker.io
    repository: bitnami/postgresql
    tag: latest
    # When in dev use:
    # registry: 806137713344.dkr.ecr.eu-west-1.amazonaws.com
    # repository: bitnami/postgresql
    # tag: sha25672c84b3980dc0f90f5e5e4470554e8994d3d2a60f622318dd29ad23b3ebf5b44
  # Enable PostgreSQL (required for Superset metadata storage)
  enabled: true

  auth:
    # Username for the application database user (used by Superset to connect)
    # This creates a non-superuser account for Superset
    username: superset
    # Password for the application user
    password: superset
    # Database name to create for Superset
    # Superset will store its metadata (dashboards, users, etc.) here
    database: superset
    # Password for the PostgreSQL superuser (postgres)
    # Required for administrative tasks and initial setup
    # postgresPassword: superset123

  primary:
    persistence:
      # Enable persistent storage for PostgreSQL data
      # Prevents data loss when pods restart
      enabled: true
      # Size of the persistent volume
      size: 8Gi

# Redis for caching and Celery task queue
redis:
  image:
    registry: docker.io
    repository: bitnami/redis
    tag: latest
    # When in dev use:
    # registry: 806137713344.dkr.ecr.eu-west-1.amazonaws.com
    # repository: bitnami/redis
    # tag: sha256-142ab4d0c251bcf5466fffd33766350af718a6725cb926710be19fad00b2b035

  # Enable Redis (required for Superset caching and async tasks)
  enabled: true
  # Redis authentication configuration
  auth:
    # Enable password authentication
    enabled: true
    # Password for Redis - must match what Superset expects
    # The Superset chart will automatically configure this
    password: superset

  master:
    persistence:
      # Enable persistent storage for Redis data
      # Stores cached data and Celery task queue across restarts
      enabled: true
      # Size of the persistent volume
      size: 8Gi

# Resource limits for k3d cluster
resources:
  requests:
    # Minimal CPU guaranteed for Superset pod
    # Reason: Ensures the pod always has 100m (0.1 CPU) available on the node.
    cpu: 100m
    # Minimal memory guaranteed for Superset pod
    # Reason: Ensures the pod has enough memory to avoid out-of-memory errors.
    memory: 512Mi
  limits:
    # Max CPU available to the Superset pod
    # Reason: Prevents the pod from using more than 1 CPU core.
    cpu: 1000m
    # Max memory for the pod
    # Reason: Prevents pod from consuming more than 1Gi memory, protecting the node from overuse.
    memory: 1Gi

# Additional worker resources
supersetWorker:
  resources:
    requests:
      # CPU guaranteed for Celery worker pods
      # Reason: Ensures stable resource allocation for background task processing.
      cpu: 100m
      # Minimal memory guaranteed for worker pods.
      memory: 512Mi
    limits:
      # Max CPU for worker pods
      cpu: 500m
      # Max memory for worker pods
      memory: 1Gi

# Disable default ingress (using Traefik IngressRoute instead)
ingress:
  # Disables the default ingress created by the Helm chart
  # Reason: Allows using a custom IngressRoute (Traefik) defined elsewhere in the deployment.
  enabled: false

# Security context
# Run pod as root user (UID 0)
# Reason: Sometimes necessary for custom images or needing special permissions,
# but generally consider using a non-root user for better security.
runAsUser: 0
